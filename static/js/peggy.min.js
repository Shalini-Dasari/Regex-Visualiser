// Peggy.js minified distribution file
// This is a placeholder - in a real implementation, we'd download the actual minified library
// from https://cdn.jsdelivr.net/npm/peggy/lib/peg.min.js
(function(root,factory){if(typeof define==="function"&&define.amd){define([],factory)}else if(typeof module==="object"&&module.exports){module.exports=factory()}else{root.peggy=factory()}})(this,function(){var peggy={};

// This is a simplified version of peggy for demonstration purposes
peggy.generate = function(grammar) {
  // In a real implementation, this would compile the grammar
  // For our demo, we'll create a simple parser object
  return {
    parse: function(input) {
      // Create a minimal parse tree for demonstration
      return createDemoParseTree(input);
    }
  };
};

// Create a simple demonstration parse tree
function createDemoParseTree(input) {
  // This is a very simplified parser for demo purposes
  // In a real implementation, we would use the actual peggy parser
  
  if (!input) {
    return { type: 'empty', value: '', children: [] };
  }
  
  // Very basic parse tree for demos
  let root = { type: 'expression', value: input, children: [] };
  
  // Check for alternation
  if (input.includes('|')) {
    root.type = 'alternative';
    root.value = '|';
    const parts = input.split('|');
    for (const part of parts) {
      root.children.push({ 
        type: 'sequence', 
        value: part,
        children: part.split('').map(c => ({ type: 'char', value: c, children: [] }))
      });
    }
    return root;
  }
  
  // Check for groups
  let groups = [];
  let inGroup = false;
  let groupStart = -1;
  let depth = 0;
  
  for (let i = 0; i < input.length; i++) {
    if (input[i] === '(') {
      depth++;
      if (depth === 1) {
        groupStart = i;
        inGroup = true;
      }
    } else if (input[i] === ')') {
      depth--;
      if (depth === 0 && inGroup) {
        groups.push({ start: groupStart, end: i });
        inGroup = false;
      }
    }
  }
  
  if (groups.length > 0) {
    root.type = 'sequence';
    root.value = '';
    
    let lastEnd = 0;
    for (const group of groups) {
      // Add chars before group
      if (group.start > lastEnd) {
        const beforeGroup = input.substring(lastEnd, group.start);
        root.children.push({
          type: 'chars',
          value: beforeGroup,
          children: beforeGroup.split('').map(c => ({ type: 'char', value: c, children: [] }))
        });
      }
      
      // Add group
      const groupContent = input.substring(group.start + 1, group.end);
      root.children.push({
        type: 'group',
        value: '()',
        children: [createDemoParseTree(groupContent)]
      });
      
      lastEnd = group.end + 1;
    }
    
    // Add chars after last group
    if (lastEnd < input.length) {
      const afterGroup = input.substring(lastEnd);
      root.children.push({
        type: 'chars',
        value: afterGroup,
        children: afterGroup.split('').map(c => ({ type: 'char', value: c, children: [] }))
      });
    }
    
    return root;
  }
  
  // Simple sequence of characters
  root.type = 'sequence';
  root.value = '';
  
  // Process each character
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    
    // Check for quantifiers
    if (i > 0 && '?*+'.includes(char)) {
      const prevChar = root.children[root.children.length - 1];
      root.children.pop();
      root.children.push({
        type: 'quantified',
        value: prevChar.value + char,
        children: [
          prevChar,
          { type: 'quantifier', value: char, children: [] }
        ]
      });
      continue;
    }
    
    // Character class
    if (char === '[') {
      const endBracket = input.indexOf(']', i);
      if (endBracket > i) {
        const charClass = input.substring(i, endBracket + 1);
        root.children.push({
          type: 'charClass',
          value: charClass,
          children: []
        });
        i = endBracket;
        continue;
      }
    }
    
    // Regular character
    root.children.push({ type: 'char', value: char, children: [] });
  }
  
  return root;
}

return peggy;
});